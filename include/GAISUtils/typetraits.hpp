// Generated by Henrik Stuart's .hpp generator: www.unprompted.com/hstuart/
#ifndef typetraits_hpp_ad8a45ea_f617_444c_85ed_dfe49806caa9
#define typetraits_hpp_ad8a45ea_f617_444c_85ed_dfe49806caa9


#include <cstdlib>

namespace Dot {

	namespace Traits {

///////////////////////////////////////////////////////////////////////////
//	class streambuf
///////////////////////////////////////////////////////////////////////////

		//	Converts each integral constant into a unique type
		//	Useful for compile time if-else statements
		template<int v>
		struct Int2Type {
			enum { value = v };
		};	//	end of struct Int2Type

///////////////////////////////////////////////////////////////////////////
//	class TypeTraits
///////////////////////////////////////////////////////////////////////////

		//	defines useful typetraits for types
		template<typename T>
		class TypeTraits {
		public : 
			typedef T Type;
			typedef T& RefType;
			typedef T* PointerType;

		protected : 
			inline explicit TypeTraits() {}
			inline ~TypeTraits() {}

		private : 
			inline explicit TypeTraits(TypeTraits const&) {}
			inline TypeTraits& operator=(TypeTraits const&) { return *this; }
		};	//	end of class TypeTraits

///////////////////////////////////////////////////////////////////////////
//	helpers for << operators
///////////////////////////////////////////////////////////////////////////

		//	since unable to overload << due to ambigous calls,
		//	resort to create type traits, and overloading those with problems
		template <typename T>
		struct StreamTypeTraits {
			typedef T StreamT;
		};

		template <>
		struct StreamTypeTraits<std::size_t> {
			typedef unsigned long StreamT;
		};

		template <>
		struct StreamTypeTraits<unsigned char> {
			typedef unsigned short StreamT;
		};

	};	//	end of namespace Traits

};	//	end of namespace Dot


#endif // typetraits_hpp_ad8a45ea_f617_444c_85ed_dfe49806caa9
